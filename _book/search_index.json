[
["scalersvectors.html", "Chapter 5 Scalars and vectors 5.1 Scalars 5.2 Vectors 5.3 Generating random data 5.4 Test your R might!", " Chapter 5 Scalars and vectors Figure 5.1: Visual depiction of a scalar and vector. Deep shit. Wait until we get to matrices - you’re going to lose it. # Crew information captain.name &lt;- &quot;Jack&quot; captain.age &lt;- 33 crew.names &lt;- c(&quot;Heath&quot;, &quot;Vincent&quot;, &quot;Maya&quot;, &quot;Becki&quot;) crew.ages &lt;- c(19, 35, 22, 44) crew.sex &lt;- c(rep(&quot;M&quot;, times = 2), rep(&quot;F&quot;, times = 2)) crew.ages.decade &lt;- crew.ages / 10 # Earnings over first 10 days at sea days &lt;- 1:10 gold &lt;- seq(from = 10, to = 100, by = 10) silver &lt;- rep(50, times = 10) total &lt;- gold + silver People are not objects. But R is full of them. Here are some of the basic ones. 5.1 Scalars The simplest object type in R is a scalar. A scalar object is just a single value like a number or a name. In the previous chapter we defined several scalar objects. Here are examples of numeric scalars: # Examples of numeric scalers a &lt;- 100 b &lt;- 3 / 100 c &lt;- (a + b) / b Scalars don’t have to be numeric, they can also be characters (also known as strings). In R, you denote characters using quotation marks. Here are examples of character scalars: # Examples of character scalers d &lt;- &quot;ship&quot; e &lt;- &quot;cannon&quot; f &lt;- &quot;Do any modern armies still use cannons?&quot; As you can imagine, R treats numeric and character scalars differently. For example, while you can do basic arithmetic operations on numeric scalars – they won’t work on character scalars. If you try to perform numeric operations (like addition) on character scalars, you’ll get an error like this one: a &lt;- &quot;1&quot; b &lt;- &quot;2&quot; a + b Error in a + b: non-numeric argument to binary operator If you see an error like this one, it means that you’re trying to apply numeric operations to character objects. That’s just sick and wrong. 5.2 Vectors Now let’s move onto vectors. A vector object is just a combination of several scalars stored as a single object. For example, the numbers from one to ten could be a vector of length 10, and the characters in the English alphabet could be a vector of length 26. Like scalars, vectors can be either numeric or character (but not both!). There are many ways to create vectors in R. Here are the methods we will cover in this chapter: Functions to create vectors. Function Example Result c(a, b, ...) c(1, 5, 9) 1, 5, 9 a:b 1:5 1, 2, 3, 4, 5 seq(from, to, by, length.out) seq(from = 0, to = 6, by = 2) 0, 2, 4, 6 rep(x, times, each, length.out) rep(c(7, 8), times = 2, each = 2) 7, 7, 8, 8, 7, 7, 8, 8 The simplest way to create a vector is with the c() function. The c here stands for concatenate, which means “bring them together”. The c() function takes several scalars as arguments, and returns a vector containing those objects. When using c(), place a comma in between the objects (scalars or vectors) you want to combine: Let’s use the c() function to create a vector called a containing the integers from 1 to 5. # Create an object a with the integers from 1 to 5 a &lt;- c(1, 2, 3, 4, 5) # Print the result a ## [1] 1 2 3 4 5 As you can see, R has stored all 5 numbers in the object a. Thanks R! You can also create longer vectors by combining vectors you have already defined. Let’s create a vector of the numbers from 1 to 10 by first generating a vector a from 1 to 5, and a vector b from 6 to 10 then combine them into a single vector x: a &lt;- c(1, 2, 3, 4, 5) b &lt;- c(6, 7, 8, 9, 10) x &lt;- c(a, b) x ## [1] 1 2 3 4 5 6 7 8 9 10 You can also create character vectors by using the c() function to combine character scalars into character vectors: Figure 5.2: This is not a pipe. It is a character vector. char.vec &lt;- c(&quot;Ceci&quot;, &quot;nest&quot;, &quot;pas&quot;, &quot;une&quot;, &quot;pipe&quot;) char.vec ## [1] &quot;Ceci&quot; &quot;nest&quot; &quot;pas&quot; &quot;une&quot; &quot;pipe&quot; While the c() function is the most straightforward way to create a vector, it’s also one of the most tedious. For example, let’s say you wanted to create a vector of all integers from 1 to 100. You definitely don’t want to have to type all the numbers into a c() operator. Thankfully, R has many simple built-in functions for generating numeric vectors. Let’s start with three of them: a:b, seq(), and rep(): 5.2.1 a:b The a:b function takes two numeric scalars a and b as arguments, and returns a vector of numbers from the starting point a to the ending point b in steps of 1. Here are some examples of the a:b function in action. As you’ll see, you can go backwards or forwards, or make sequences between non-integers: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 2.5:8.5 ## [1] 2.5 3.5 4.5 5.5 6.5 7.5 8.5 5.2.2 seq() Argument Definition from The start of the sequence to The end of the sequence by The step-size of the sequence length.out The desired length of the final sequence (only use if you don’t specify by) The seq() function is a more flexible version of a:b. Like a:b, seq() allows you to create a sequence from a starting number to an ending number. However, seq(), has additional arguments that allow you to specify either the size of the steps between numbers, or the total length of the sequence: The seq() function has two new arguments by and length.out. If you use the by argument, the sequence will be in steps of the input to the by argument: # Create the numbers from 1 to 10 in steps of 1 seq(from = 1, to = 10, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 # Integers from 0 to 100 in steps of 10 seq(from = 0, to = 100, by = 10) ## [1] 0 10 20 30 40 50 60 70 80 90 100 If you use the length.out argument, the sequence will have length equal to length.out. # Create 10 numbers from 1 to 5 seq(from = 1, to = 5, length.out = 10) ## [1] 1.0 1.4 1.9 2.3 2.8 3.2 3.7 4.1 4.6 5.0 # 3 numbers from 0 to 100 seq(from = 0, to = 100, length.out = 3) ## [1] 0 50 100 5.2.3 rep() Argument Definition x A scalar or vector of values to repeat times The number of times to repeat x each The number of times to repeat each value within x length.out The desired length of the final sequence Figure 5.3: Not a good depiction of a rep in R. The rep() function allows you to repeat a scalar (or vector) a specified number of times, or to a desired length. Let’s do some reps. rep(x = 3, times = 10) ## [1] 3 3 3 3 3 3 3 3 3 3 rep(x = c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 rep(x = 1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1 As you can see, you can can include an a:b call within a rep()! You can even combine the times and each arguments within a single rep() function. For example, here’s how to create the sequence {1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3} with one call to rep(): rep(x = 1:3, each = 2, times = 2) ## [1] 1 1 2 2 3 3 1 1 2 2 3 3 Warning! Vectors contain either numbers or characters, not both A vector can only contain one type of scalar: either numeric or character. If you try to create a vector with numeric and character scalars, then R will convert all of the numeric scalars to characters. In the next code chunk, I’ll create a new vector called my.vec that contains a mixture of numeric and character scalars. my.vec &lt;- c(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3) my.vec ## [1] &quot;a&quot; &quot;1&quot; &quot;b&quot; &quot;2&quot; &quot;c&quot; &quot;3&quot; As you can see from the output, my.vec is stored as a character vector where all the numbers are converted to characters. 5.3 Generating random data Because R is a language built for statistics, it contains many functions that allow you generate random data – either from a vector of data that you specify (like Heads or Tails from a coin), or from an established probability distribution, like the Normal or Uniform distribution. In the next section we’ll go over the standard sample() function for drawing random values from a vector. We’ll then cover some of the most commonly used probability distributions: Normal and Uniform. 5.3.1 sample() Argument Definition x A vector of outcomes you want to sample from. For example, to simulate coin flips, you’d enter x = c(&quot;H&quot;, &quot;T&quot;) size The number of samples you want to draw. The default is the length of x. replace Should sampling be done with replacement? If FALSE (the default value), then each outcome in x can only be drawn once. If TRUE, then each outcome in x can be drawn multiple times. prob A vector of probabilities of the same length as x indicating how likely each outcome in x is. The vector of probabilities you give as an argument should add up to one. If you don’t specify the prob argument, all outcomes will be equally likely. The sample() function allows you to draw random samples of elements (scalars) from a vector. For example, if you want to simulate the 100 flips of a fair coin, you can tell the sample function to sample 100 values from the vector [“Heads”, “Tails”]. Or, if you need to randomly assign people to either a “Control” or “Test” condition in an experiment, you can randomly sample values from the vector [“Control”, “Test”]: Let’s use sample() to draw 10 samples from a vector of integers from 1 to 10. # From the integers 1:10, draw 5 numbers sample(x = 1:10, size = 5) ## [1] 6 1 2 9 10 5.3.1.1 replace = TRUE If you don’t specify the replace argument, R will assume that you are sampling without replacement. In other words, each element can only be sampled once. If you want to sample with replacement, use the replace = TRUE argument: Think about replacement like drawing balls from a bag. Sampling with replacement (replace = TRUE) means that each time you draw a ball, you return the ball back into the bag before drawing another ball. Sampling without replacement (replace = FALSE) means that after you draw a ball, you remove that ball from the bag so you can never draw it again. # Draw 30 samples from the integers 1:5 with replacement sample(x = 1:5, size = 10, replace = TRUE) ## [1] 4 3 2 4 4 1 5 3 2 4 If you try to draw a large sample from a vector replacement, R will return an error because it runs out of things to draw: # You CAN&#39;T draw 10 samples without replacement from # a vector with length 5 sample(x = 1:5, size = 10) Error: cannot take a sample larger than the population when ‘replace = FALSE’ To fix this, just tell R that you want to sample with replacement: # You CAN draw 10 samples with replacement from a # vector of length 5 sample(x = 1:5, size = 10, replace = TRUE) ## [1] 2 2 1 5 4 2 5 5 3 1 To specify how likely each element in the vector x should be selected, use the prob argument. The length of the prob argument should be as long as the x argument. For example, let’s draw 10 samples (with replacement) from the vector [“a”, “b”], but we’ll make the probability of selecting “a” to be .90, and the probability of selecting “b” to be .10 sample(x = c(&quot;a&quot;, &quot;b&quot;), prob = c(.9, .1), size = 10, replace = TRUE) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; 5.3.1.2 Ex: Simulating coin flips Let’s simulate 10 flips of a fair coin, were the probably of getting either a Head or Tail is .50. Because all values are equally likely, we don’t need to specify the prob argument sample(x = c(&quot;H&quot;, &quot;T&quot;), # The possible values of the coin size = 10, # 10 flips replace = TRUE) # Sampling with replacement ## [1] &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; Now let’s change it by simulating flips of a biased coin, where the probability of Heads is 0.8, and the probability of Tails is 0.2. Because the probabilities of each outcome are no longer equal, we’ll need to specify them with the prob argument: sample(x = c(&quot;H&quot;, &quot;T&quot;), prob = c(.8, .2), # Make the coin biased for Heads size = 10, replace = TRUE) ## [1] &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; As you can see, our function returned a vector of 10 values corresponding to our sample size of 10. 5.3.1.3 Ex: Coins from a chest Now, let’s sample drawing coins from a treasure chest Let’s say the chest has 100 coins: 20 gold, 30 silver, and 50 bronze. Let’s draw 10 random coins from this chest. # Create chest with the 100 coins chest &lt;- c(rep(&quot;gold&quot;, 20), rep(&quot;silver&quot;, 30), rep(&quot;bronze&quot;, 50)) # Draw 10 coins from the chest sample(x = chest, size = 10) ## [1] &quot;bronze&quot; &quot;gold&quot; &quot;bronze&quot; &quot;silver&quot; &quot;bronze&quot; &quot;bronze&quot; &quot;bronze&quot; ## [8] &quot;bronze&quot; &quot;silver&quot; &quot;bronze&quot; The output of the sample() function above is a vector of 10 strings indicating the type of coin we drew on each sample. And like any random sampling function, this code will likely give you different results every time you run it! See how long it takes you to get 10 gold coins… In the next section, we’ll cover how to generate random data from specified probability distributions. What is a probability distribution? Well, it’s simply an equation – also called a likelihood function – that indicates how likely certain numerical values are to be drawn. We can use probability distributions to represent different types of data. For example, imagine you need to hire a new group of pirates for your crew. You have the option of hiring people from one of two different pirate training colleges that produce pirates of varying quality. One college “Pirate Training Unlimited” might tend to pirates that are generally ok - never great but never terrible. While another college “Unlimited Pirate Training” might produce pirates with a wide variety of quality, from very low to very high. In Figure 5.4 I plotted 5 example pirates from each college, where each pirate is shown as a ball with a number written on it. As you can see, pirates from PTU all tend to be clustered between 40 and 60 (not terrible but not great), while pirates from UPT are all over the map, from 0 to 100. We can use probability distributions (in this case, the uniform distribution) to mathematically define how likely any possible value is to be drawn at random from a distribution. We could describe Pirate Training Unlimited with a uniform distribution with a small range, and Unlimited Pirate Training with a second uniform distribution with a wide range. Figure 5.4: Sampling 5 potential pirates from two different pirate colleges. Pirate Training Unlimited (PTU) consistently produces average pirates (with scores between 40 and 60), while Unlimited Pirate Training (UPT), produces a wide range of pirates from 0 to 100. In the next two sections, I’ll cover the two most common distributions: The Normal and the Uniform. However, R contains many more distributions than just these two. To see them all, look at the help menu for Distributions: # See all distributions included in Base R ?Distributions 5.3.2 Normal (Gaussian) Figure 5.5: Three different normal distributions with different means and standard deviations Argument Definition n The number of observations to draw from the distribution. mean The mean of the distribution. sd The standard deviation of the distribution. The Normal (a.k.a “Gaussian”) distribution is probably the most important distribution in all of statistics. The Normal distribution is bell-shaped, and has two parameters: a mean and a standard deviation. To generate samples from a normal distribution in R, we use the function rnorm() # 5 samples from a Normal dist with mean = 0, sd = 1 rnorm(n = 5, mean = 0, sd = 1) ## [1] -0.5205 -0.4547 0.0998 -1.5918 -0.0031 # 3 samples from a Normal dist with mean = -10, sd = 15 rnorm(n = 3, mean = -10, sd = 15) ## [1] -7.5 -28.5 18.4 Again, because the sampling is done randomly, you’ll get different values each time you run rnorm() 5.3.3 Uniform Figure 5.6: The Uniform distribution - known colloquially as the Anthony Davis distribution. Next, let’s move on to the Uniform distribution. The Uniform distribution gives equal probability to all values between its minimum and maximum values. In other words, everything between its lower and upper bounds are equally likely to occur. To generate samples from a uniform distribution, use the function runif(), the function has 3 arguments: Argument Definition n The number of observations to draw from the distribution. min The lower bound of the Uniform distribution from which samples are drawn max The upper bound of the Uniform distribution from which samples are drawn Here are some samples from two different Uniform distributions: # 5 samples from Uniform dist with bounds at 0 and 1 runif(n = 5, min = 0, max = 1) ## [1] 0.731 0.579 0.044 0.174 0.281 # 10 samples from Uniform dist with bounds at -100 and +100 runif(n = 10, min = -100, max = 100) ## [1] 83.9 -80.8 26.2 -4.5 75.6 -72.4 20.5 95.1 44.0 29.3 5.3.4 Notes on random samples 5.3.4.1 Random samples will always change Every time you draw a sample from a probability distribution, you’ll (likely) get a different result. For example, see what happens when I run the following two commands (you’ll learn the rnorm() function on the next page…) # Draw a sample of size 5 from a normal distribution with mean 100 and sd 10 rnorm(n = 5, mean = 100, sd = 10) ## [1] 88 105 96 84 97 # Do it again! rnorm(n = 5, mean = 100, sd = 10) ## [1] 102 112 108 82 101 As you can see, the exact same code produced different results – and that’s exactly what we want! Each time you run rnorm(), or another distribution function, you’ll get a new random sample. 5.3.4.2 Use set.seed() to control random samples There will be cases where you will want to exert some control over the random samples that R produces from sampling functions. For example, you may want to create a reproducible example of some code that anyone else can replicate exactly. To do this, use the set.seed() function. Using set.seed() will force R to produce consistent random samples at any time on any computer. In the code below I’ll set the sampling seed to 100 with set.seed(100). I’ll then run rnorm() twice. The results will always be consistent (because we fixed the sampling seed). # Fix sampling seed to 100, so the next sampling functions # always produce the same values set.seed(100) # The result will always be -0.5022, 0.1315, -0.0789 rnorm(3, mean = 0, sd = 1) ## [1] -0.502 0.132 -0.079 # The result will always be 0.887, 0.117, 0.319 rnorm(3, mean = 0, sd = 1) ## [1] 0.89 0.12 0.32 Try running the same code on your machine and you’ll see the exact same samples that I got above. Oh and the value of 100 I used above in set.seed(100) is totally arbitrary – you can set the seed to any integer you want. I just happen to like how set.seed(100) looks in my code. 5.4 Test your R might! Create the vector [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] in three ways: once using c(), once using a:b, and once using seq(). Create the vector [2.1, 4.1, 6.1, 8.1] in two ways, once using c() and once using seq() Create the vector [0, 5, 10, 15] in 3 ways: using c(), seq() with a by argument, and seq() with a length.out argument. Create the vector [101, 102, 103, 200, 205, 210, 1000, 1100, 1200] using a combination of the c() and seq() functions A new batch of 100 pirates are boarding your ship and need new swords. You have 10 scimitars, 40 broadswords, and 50 cutlasses that you need to distribute evenly to the 100 pirates as they board. Create a vector of length 100 where there is 1 scimitar, 4 broadswords, and 5 cutlasses in each group of 10. That is, in the first 10 elements there should be exactly 1 scimitar, 4 broadswords and 5 cutlasses. The next 10 elements should also have the same number of each sword (and so on). Create a vector that repeats the integers from 1 to 5, 10 times. That is [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …]. The length of the vector should be 50! Now, create the same vector as before, but this time repeat 1, 10 times, then 2, 10 times, etc., That is [1, 1, 1, …, 2, 2, 2, …, … 5, 5, 5]. The length of the vector should also be 50 Create a vector containing 50 samples from a Normal distribution with a population mean of 20 and standard deviation of 2. Create a vector containing 25 samples from a Uniform distribution with a lower bound of -100 and an upper bound of -50. "]
]
